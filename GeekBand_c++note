monolake 的GeekBand C++开发学习笔记（一）

前记：开始第一课GeekBand C++开发工程师课程的学习，同时也开始写自己的第一篇C++笔记博客，记录下自己的疑惑，并寻找解答，这种探索的过程竟也如此有趣。

指针和引用

在课堂上的例子complex类中的定义了一个友元函数

friend complex& __doapl (complex *,const complex& );
1
1
其中第一参数使用的是complex *指针，第二函数是const complex& 引用。侯捷老师上课时说过，尽量先使用引用，然后考虑这样用行不行的通。 
那么为什么不将第一个指针换成complex&引用？然后我做了将指针替换为complex& 引用的尝试：

friend complex& __doapl (complex &,const complex& );    
1
1
inline complex&
__doapl (complex& ths, const complex& r)
{
  ths.re += r.re;
  ths.im += r.im;
  return ths;
}
1
2
3
4
5
6
7
1
2
3
4
5
6
7
inline m_complex&
m_complex::operator +=(m_complex& b)
{
    return __doapl(*this, b);
}
1
2
3
4
5
1
2
3
4
5
然后开始编译：编译通过，得出结果正确。说明使用complex&引用是可行的。但为什么不使用引用呢？

网上查找了c++引用的资料，发现引用是编译器通过指针实现的参考[1]。即说明引用和指针都是通过传递地址实现参数传递，这个比按值传递本体的COPY要高效许多（在传递的参数对象越大的情况下越明显）。所以优先考虑使用引用，而引用和指针的效率几乎一致。

那么新的问题来了，既然引用底层是通过指针实现的，那么他们一样吗？有什么共同或不同点呢？或者说为什么提倡使用引用呢？再次网上搜索资料参考[2]:

相同点：都是地址的概念 
指针指向一块内存，内容为所指内存的地址，引用为某块内存的别名。
不同点： 
指针是一个实体，而引用只是个别名。
指针使用所指内容时需使用（*）解除引用，而引用则无需如此。
指针可以为空，可以改变所指内容；而引用不可以为空，只能且必须在定义时进行初始化，以后不能改变，可以说是从一而终。
‘sizeof引用’得到的是所指变量(对象)的大小，’sizeof指针’得到的是自身（地址）的大小；typeid(T)==typeid(T&)恒成立，sizeof(T)==sizeof(T&)恒成立。
指针的自加(++)是地址的后移，引用的自加(++)是所指变量(对象)的增加。
从以上几点可以看出，引用一般情况下可以理解成一个安全规范的指针，不可为空，只能指向初始变量(对象)，使用起来方便安全，但功能没有指针多。而指针使用相当功能多样、灵活多变，但是安全可靠性不如引用。

回到开始的那个函数，能够看出__doapl函数是为+=的重载函数服务的，+=重载在类中是成员函数，使用自带this指针访问自身数据。如果将__doapl函数的第一参数改成引用的话，则需要将+=重载函数中的this指针解除引用(*)，然后作为引用参数传递给__doapl函数。既然指针和引用效率一致，而且又无其他安全性要求，还不如直接将this 指针作为参数传给__doapl函数，这样少了一次解除引用和引用的过程，更加有效率。
